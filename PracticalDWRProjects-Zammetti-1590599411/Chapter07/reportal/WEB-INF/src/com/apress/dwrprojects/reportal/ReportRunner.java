package com.apress.dwrprojects.reportal;


import java.io.PrintWriter;
import java.io.StringReader;
import java.io.StringWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import jimm.datavision.layout.CSSHTMLLE;
import jimm.datavision.Report;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.Job;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;


/**
 * This class performs operations dealing with actually running a report.  Also
 * note that this class implements Job, for use with Quartz.
 *
 * @author <a href="mailto:fzammetti@omnytex.com">Frank W. Zammetti</a>.
 */
public class ReportRunner implements Job {


  /**
   * Log instance.
   */
  private static Log log = LogFactory.getLog(ReportRunner.class);


  /**
   * SQL for getting the XML for a report.
   */
  private static String SQL_GET_REPORT_XML =
    "SELECT datasourcename, reportxml FROM reports " +
    "where reportname='${reportname}'";


  /**
   * SQL for updating a scheduled report when the report runs.
   */
  private static String SQL_UPDATE_SCHEDULED_RUN =
    "UPDATE schedules SET lastrun='${lastrun}', " +
    "lastrunstatus='${lastrunstatus}', lastrunoutput='${lastrunoutput}' " +
    "WHERE reportname='${reportname}' AND " +
    "daysofweek='${daysofweek}' AND runtime='${runtime}'";


  /**
   * Instance of DatabaseWorker to use for all database access.
   */
  private DatabaseWorker databaseWorker;


  /**
   * Setter for databaseWorker so Spring can give it to us.
   */
  public void setDatabaseWorker(final DatabaseWorker inDatabaseWorker) {

    databaseWorker = inDatabaseWorker;

  } // End setDatabaseWorker().


  /**
   * This method actually runs a report and returns a string of HTML that
   * is the generated output of the report.
   *
   * @param  inReportName The name of the report to run.
   * @return              A string of HTML that is the report output.
   * @throws Exception    If anything goes wrong.
   */
  public String runReport(final String inReportName) throws Exception {

    log.trace("runReport() - Entry");

    Connection conn = null;

    try {

      if (log.isDebugEnabled()) {
        log.debug("runReport() - inReportName = " + inReportName);
      }

      // Tokens for SQL replacement.
      Map<String, String> tokens = new HashMap<String, String>();
      tokens.put("reportname", inReportName);

      // Get record from database for the specified report.
      List resultSet = databaseWorker.executeQuery(SQL_GET_REPORT_XML, tokens);

      // Get the data source and report XML from the record.
      Map m = (Map)resultSet.get(0);
      String dataSourceName = (String)m.get("DATASOURCENAME");
      String reportXML = (String)m.get("REPORTXML");
      if (log.isDebugEnabled()) {
        log.debug("runReport() - dataSourceName = " + dataSourceName);
        log.debug("runReport() - reportXML = " + reportXML);
      }

      // Next we'll get a connection to our database.  To do so, we need to
      // first look up the data source info in Config, then construct the
      // data source.
      DataSourceDescriptor dsd = Config.getDataSource(dataSourceName);
      if (log.isDebugEnabled()) {
        log.debug("runReport() - DataSourceDescriptor = " + dsd);
      }
      String jdbcDriverClassName = dsd.getDatabaseDriver();
      String connectionInfo = dsd.getDatabaseURI();
      String userName = dsd.getDatabaseUsername();
      String password = dsd.getDatabasePassword();
      Class.forName(jdbcDriverClassName);
      conn = DriverManager.getConnection(connectionInfo, userName, password);
      if (log.isDebugEnabled()) {
        log.debug("runReport() - Connection created");
      }

      // Now we'll set up DataVision.  We instantiate a report instance and
      // hand it the database connection and the XML, and tell it we want HTML
      // as our output.
      Report report = new Report();
      report.setDatabaseConnection(conn);
      StringReader sbis = new StringReader(reportXML);
      report.read(new org.xml.sax.InputSource(sbis));
      StringWriter sw = new StringWriter();
      report.setLayoutEngine(new CSSHTMLLE(new PrintWriter(sw)));

      // Finally, run the report!
      if (log.isDebugEnabled()) {
        log.debug("runReport() - Running report...");
      }
      report.runReport();

      // Return HTML generated by report.
      log.trace("runReport() - Exit");
      return sw.toString();

    } catch (Exception e) {
      e.printStackTrace();
      throw e;
    } finally {
      if (conn != null) {
        try {
          conn.close();
        } catch (Exception e) {
          // Eat this exception, for the sake of simplicity.
        }
      }
    }

  } // End runReport().


  /**
   * This method is called to get the list of data sources reports can use.
   *
   * @return           A List of DataSourceDescriptor objects, one for each
   *                   data source configured on the portal.
   * @throws Exception If anything goes wrong.
   */
  public List<DataSourceDescriptor> getDataSourceList() throws Exception {

    log.trace("getDataSourceList() - Entry");

    try {

      List<DataSourceDescriptor> dataSources =
        new ArrayList<DataSourceDescriptor>();
      Map<String, DataSourceDescriptor> cds = Config.getDataSources();
      for (String dsKey : cds.keySet()) {
        dataSources.add(cds.get(dsKey));
      }
      log.trace("getDataSourceList() - Exit");
      return dataSources;

    } catch (Exception e) {
      e.printStackTrace();
      throw e;
    }

  } // End getDataSourceList().


  /**
   * This method is called when a report is scheduled to run.
   *
   * @param  inContent             The job execution context for the scheduled
   *                               report job.
   * @throws JobExecutionException If anything goes wrong.
   */
  public void execute(JobExecutionContext inContext)
    throws JobExecutionException {

    log.trace("execute() - Entry");

    String reportName = "unknown";

    try {

      // Get name of report to run from job detail.
      JobDataMap dataMap = inContext.getJobDetail().getJobDataMap();
      reportName = dataMap.getString("reportName");
      if (log.isDebugEnabled()) {
        log.debug("execute() - reportName = " + reportName);
      }

      // We need a DatabaseWorker here to do the work.
      databaseWorker = new DatabaseWorker();

      // Run the report and get the generated HTML.
      String reportOutput = runReport(reportName);

      // Write the report output to the database.  Start by creating a map of
      // replacement tokens for SQL statement.
      Map<String, String> tokens = new HashMap<String, String>();
      tokens.put("reportname", reportName);
      tokens.put("daysofweek", dataMap.getString("daysOfWeek"));
      tokens.put("runtime", dataMap.getString("runTime"));
      tokens.put("lastrunoutput", reportOutput);
      tokens.put("lastrunstatus", "OK");
      tokens.put("lastrun", new Date().toString());
      databaseWorker.executeUpdate(SQL_UPDATE_SCHEDULED_RUN, tokens);

    } catch (Exception e) {
      log.error("execute() - Exception(1): " + e);
      try {
        Map<String, String> tokens = new HashMap<String, String>();
        tokens.put("reportname", reportName);
        tokens.put("runtime", "-");
        tokens.put("daysofweek", "-");
        tokens.put("lastrunoutput", "");
        tokens.put("lastrunstatus", "ERROR");
        tokens.put("lastrun", e.getMessage());
        databaseWorker.executeUpdate(SQL_UPDATE_SCHEDULED_RUN, tokens);
        throw new JobExecutionException(e.getMessage());
      } catch (Exception e1) {
        log.error("execute() - Exception(2): " + e1);
        throw new JobExecutionException(e1.getMessage());
      }
    }

    log.trace("execute() - Exit");

  } // End execute().


} // End class.
